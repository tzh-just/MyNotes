# Niagara性能分析工具
## 静态性能分析
静态分析工具以插件的形式提供，主要通过继承静态函数扩展类，把分析调用的接口暴露给蓝图或者脚本。同py脚本设置为启动引擎自动执行，将结果保存在json中，接入腾讯的自动化流水线。
引擎组为美术提供一些资产制作规范以及母材质，溶解遮罩等
例如
纹理大小原则上不能超过515x512
纹理的个数不能超过6张
如果资产使用了过多的母材质提供的功能，回迅速带来采样个数和gpu指令数的增加

粒子发射器的个数不超过15个

粒子的发射个数在pc端不超过100，移动端不超过25

使用mesh renderer的mesh使用高模有很大的性能开销。
如果是透明的材质，renderer的面积过大会造成严重的overdraw

### 动态性能分析
首先我们通过Unreal Insight分析Niagara在CPU和GPU上的耗时
发现在GameThread主要是在第一次初始化Niagara是会耗费较多时间
在渲染线程，Niagara资产名就是timeline上的节点名

对于第二点，我们希望能统计所有Niagara的特定场景中的总耗时
动态性能分析需要修改UE的Insight源码。在打开utrace文件时，insight会另起一个线程以解析文件，定位到相关代码后，出找出感兴趣的数据以特定的格式保存起来。
这些数据是按照timeline排列的，类似一个树形结构，我们只保留构建timeline必须的进出时间和id。然后使用py脚本解析这些数据，重建timeline的数据结构，找到Niagara相关的部分，在数据中统计这些数据，这样就得到了场景中的特效在一段时间内的时间开销。


行为树


性能优化
优化思路
通过unreal insight等工具分析性能热点的侧重
如果是cpu端，通常是一些功能实现频繁调用了高开销的函数，
如我们项目中行为树的寻敌节点，开发初期使用getacotrbyinterface还没有太大影响，随着场景的丰富，静态的actor数量迅速正常，换成反射机制的getactorbyclass虽然暂时解决了一部分性能问题，但消耗还是客观的，进一步的修改游戏机制，增加场景玩家管理，玩家出生或死亡才会更新玩家池，寻敌的消耗就此大大减少了。
另一种情况则是，如我们屏蔽组件旋转相关的设置，通过自己设置旋转速度和计算的方式实现旋转，这部分的蓝图实现消耗也很可观。通过去除开发等不必要的精确计算、将计算内容用C++实现，减少蓝图的调用，以及通过定时器调用而不是每帧tick来减少计算量。
gpu端美术实现了覆盖全场景的风沙平面效果材质，其中颜色和透明度都用到了采样噪声纹理来获取随机值，为了减少该效果的开销，设置了移动端直接返回1，减少纹理的采样数量。


Unity SRP
延迟渲染管线




PBR
IBL
ShadowMap
CSM


软渲染器
加速结构
路径追踪
