多重采样抗锯齿 $\text{Multi-Sampling Anti-aliasing}$ 也是将像素分为 $N \times N$ 个子像素，例如先采样 $2 \times 2$ 分辨率，有四个子像素，根据三角形覆盖四个子像素的比例决定该像素颜色。如果一个三角形占据了四分之一个子像素，则该三角形为该像素贡献了四分之一的自身颜色值。
但由于需要进行深度测试，每个子像素也都需要存储一个深度值，因此无论是 SSAA 还是 MSAA，他们的深度缓冲都将变为原来的 $2 \times 2$ 倍。考虑到多个三角形同时覆盖单个像素的不同子像素的情况，颜色缓冲也必须变为原来的 $2 \times 2$ 倍。
到此为止 MSAA 和 SSAA 没有什么不同。但是 MSAA 的像素着色时依旧只是计算单个像素的颜色，经过深度测试后，将像素的颜色和深度写入其覆盖的所有子像素，渲染结束后，对 frambuffer 进行下采样，一般是使用 box filter 进行 resolve。因此 MSAA 空间上与 SSAA 开销相同，主要节省了大量子像素的光照计算，

![img](v2-4230825a77029832fe9ee2a63ce43273_720w.webp)

此外子像素的采样 pattern 也影响

![img](v2-10a2b17ab6f4fd57750feb5b8fcadf52_720w.webp)


MSAA 与延迟渲染结合会遇到很多问题
1. MRT 需要每个 RT 的 sample 数量一致，所有 RT 都应该是同分辨率的，否则需要两次 pass。
2. 因此延迟渲染的 MRT 需要更多显存来保存 GBuffer，MSAA 会使得显存带宽暴增。
3. 延迟渲染的 GBuffer 保存的信息是世界坐标、法线和基本颜色等，而 MSAA 是对光照的结果的插值，如果此时插值，是对 basecolor 的插值，是不合理的。且子像素如果存不同图元的法线，如何插值计算光照？如果光照计算后再插值，那就是 SSAA 了。
4. 以前的 MRT 在硬件上不支持抗锯齿
