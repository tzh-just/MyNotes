
# 堆

大根堆
堆排序
完全二叉树


- 完全二叉树可以在数组中排列，除了最后一次，其他层都填满了。
	- 对于节点i，其子节点为$i\times 2+1$和$i\times 2+2$，其父节点为$(i-1)/2$ 。
	- 对于完全二叉树，从上到下从左到右数，最后一个非叶子节点的索引为$n/2$
- 对于大根堆，最大的节点为根节点，左右子节点小于自身，但没有顺序之分


## TopK
对于数组，原地建堆时，将其视为一个完全二叉树，则建堆的过程就是排序的过程。
按照完全二叉树的排列方式，我们选取最后一个非叶子节点，如下图所示为1
`p=n/2-1`
![](assets/Pasted%20image%2020230630105808.png)
获取该节点的左右子节点`l=p*2+1,r=p*2+2`，在该节点和其左右子节点中寻找最大的一个，记其索引为为largest。如果该节点不是最大的，则与最大节点交换值。继续堆化，此时largest为叶子节点，递归不符合条件返回。
```cpp
void maxHeapify(vector<int>& nums, int i, int heapSize){
	int l=i*2+1,r=i*2+2,largest=i;
	if(l<heapSize&&nums[l]>nums[largest])largest=l;
	if(r<heapSize&&nums[r]>nums[largest])largest=r;
	if(largest==i)return;
	swap(nums[i],nums[largest]);
	maxHeapify(nums, largest, heapSize);
}
```
此时for循环继续遍历非叶子节点，倒序遍历数组等价于一层层从右到左从下到上遍历二叉树。诸如子节点为叶子结点的，如上过程。对于子节点为非叶子节点的，会在交换值后，递归堆化，以确保该节点子树符合要求。
```cpp
void buildHeap(vector<int>& nums, int heapSize){
	for(int i=nums.size()/2;i>=0;i--){
		maxHeapify(nums, i, heapSize);
	}
}
```

构建好大顶堆后，要得到第k大的数，可以通过将根节点与最后的叶子节点交换值，然后抛弃最后得叶子节点，再重新从根节点开始，自顶向下地递归地堆化，经过k-1次循环后，此时大顶堆的根节点就是第k大的数。
```cpp
int findKthLargest(vector<int>& nums, int k) {
	int heapSize= nums.size();
	buildHeap(nums,heapSize);
	for(int i=nums.size()-1;i>nums.size()-k;i--){
		swap(nums[0],nums[i]);
		heapSize--;
		maxHeapify(nums,0,heapSize);
	}
	return nums[0];
}
```

# 二叉搜索树

二叉搜索树是平衡二叉树
每个节点的左右两个子树的高度差绝对值不超过1

有序数组构建二叉搜索树
二叉搜索树的节点，其左节点值比自己小，右节点值比自己大，因此将数组二分，左右子数组的mid就是节点的左右子节点。

```cpp
TreeNode* sortedArrayToBST(vector<int>& nums) {
	return helper(0, nums.size()-1, nums);
}
TreeNode* helper(int l, int r, vector<int>& nums){
	if(l>r) return nullptr;
	int mid = (l+r)/2;
	auto node=new TreeNode(nums[mid], helper(l,mid-1,nums), helper(mid+1,r,nums));
	return node;
}
```
