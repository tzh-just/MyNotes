>介绍渲染管线

应用阶段
- cpu将场景中的灯光、mesh、相机位置等信息传递给gpu
- cpu端可以根据场景管理，做视锥剔除，这是在mesh粒度上的剔除，减少向gpu传递的mesh数量。
  【重点 】GPU Driven：视锥剔除可以交给computer shader来做；遮挡剔除：Hiz、SOC
- cpu同时将材质、纹理、着色器等也传给gpu，然后向gpu发送drawcall命令， drawcall指向了一个要被渲染的顶点列表。
- cpu将命令放入命令缓冲区，gpu再取出来执行，cpu的drawcall太多往往是性能瓶颈。cpu可以通过批处理来减少drawcall的次数，以降低开销
- 【重点】动态合批是将同材质的mesh变换到世界空间后合并提交给gpu，适用于顶点数少的mesh，gpu instance对相同的mesh只提交一次，将每个mesh的变换矩阵、材质差异等送入缓冲区，在变换时把objectToWorld即M矩阵替换掉。
几何阶段
- 将顶点送入顶点着色器，在顶点着色器中进行各种变换，通过引入齐次坐标将线性变换和平移变换统一了起来。
- 这一步的最终目的是把顶点变换到-1到1的NDC空间中。首先根据模型变换到世界空间，根据相机变换到观察空间。
- 根据近平面远平面决定了投影变换的视体范围，如果是透视投影需要考虑fov，正交投影需要考虑尺寸大小。通过投影变换到齐次裁剪空间。
- 在齐次裁剪空间中可以做简单的、三角形粒度的视锥剔除，因为此时可以很容易判断三角形是否完全在视锥之外。
- 【重点】因为在透视除法后xy坐标是-1到1的，所以在除法前xy坐标的取值范围是-w到w，如果是opengl，则z也是-w到w，如果是dx则是0到w。
- 将这些三角形裁剪成多个，会更准确但也更耗费性能。对于在视锥面上的三角形可以等到在光栅化时通过视口和平面方程来裁剪。但这样简单处理实际上是有问题的。
- 【重点】因为此时如果有顶点在近平面后，在透视除法时会导致xy坐标翻转，得到不正确的NDC坐标。如果顶点恰好在视点的平面上，那么会导致除零的错误。
- NDC坐标经过屏幕映射后就得到了屏幕空间坐标。
光栅化阶段
- 顶点着色器输出的顶点数据会被组装成三角形图元，如点线面等。
- 然后对组装好的图元进行遍历，图元覆盖的每一个像素都会生成一个片元
- 【重点】图元覆盖像素的判断也有几种不同，在此基础上可以进行抗锯齿的计算，如SSAA，有四倍的颜色缓冲和深度缓冲，gpu会分配四个采样点，生成四倍的片元，进行四倍的计算，光栅化结束后将多重采样缓冲区下采样到帧缓冲。
- 【重点】MSAA与SSAA的区别在于，只会执行一次片元着色器，会根据片元与子采样点的覆盖与否，选择是否要把深度和颜色写入多重采样缓冲区，光栅化结束后将多重采样缓冲区下采样到帧缓。
- 此外，每个片元都需要根据三个顶点的数据，根据重心坐标进行插值计算，然后进行透视插值校正。片元与像素的区别就是，片元比像素多了这些插值信息。
- 【重点】之所以要做透视插值校正是因为，重心坐标是在屏幕空间计算的，计算出的结果不会考虑透视。齐次裁剪空间的w其实际上就是顶点的相机空间z值。该z值与屏幕空间的深度与其是成反比的。因此三个顶点在屏幕空间上计算得到的重心坐标需要分别除以自己的齐次裁剪空间w才是校正后的重心坐标。显然，硬件做透视除法之前得到了顶点的w，是可以自动完成这一操作的。
- 【重点】如果在片元着色器之前执行了深度测试，那么就是early-z。early-z在光照计算之前计算深度，好处是减少了不必要的overdraw，但是无法得到片元的透明度，也就不能进行半透明或全透明的渲染。
- 在片元着色器中计算光照后，如果开启了alpha测试，就会根据片元的alpha值决定是否丢弃片元，以实现全透明效果。
- 其次是进行深度测试，如果没有做early-z或开启了透明渲染，那么就会在这里进行深度测试，比较当前片元的深度与zbuffer中的深度。

>什么是Radiance和Irradiance

Radiance的定义是每单位立体角每单位投影面积接收的功率。
Irradiance的定义是Radiance在半球面上对微分立体角积分，或者说是单位面积在半球面上接收四面八方的所有能量。

>介绍渲染方程

渲染方程描述了，着色点p在出射方向上的Radiance，是由物体的自发光在出射方向上的Radiance，加上入射方向上的Radiance经过BRDF在出射方向上反射色能力，在半球面上积分的综合，简单来说就是着色点接收到的四面八方的能量后再出射方向上的Radiance。

>怎么理解BRDF

从渲染方程可以看出，对两边微分可知BRDF就等于出射方向的Radiance的微分比上入射方向的Radiance。BRDF就是计算接收到半球面上四面八方的能量后，在出射方向上分布了多少能量。

>介绍Cook-Torrance BRDF

Kd·C/pi + Ks·DFG·/4cosicoso
分为漫反射项和镜面反射项。

>为什么漫反射项要除以pi

漫反射项是兰伯特模型，假定了反射方向是均匀分布在半球面上，即其BRDF是个常数。把入射Radiance和BRDF提出积分，则积分只受到入射方向的cos项影响，在半球面上积分结果为pi。根据能量守恒，1的能量经过BRDF要小于等于1，也就是BRDF=1/pi才能保证。

>介绍镜面反射项

D是法线分布函数，只有当观察方向和光源方向的半程向量符合该法线分布时才会被反射，根据粗糙度和半程向量可以计算出被反射的比例。
F是菲涅尔项，其决定视线与物体表面法线在不同角度时的光线如何反射和折射。根据F0和F90可以近似得到菲涅尔项，其中F0是观察方向与法线重合时的反射率，F90是垂直的反射率，取值都是0-1，其中F90在近似中认为是1。常见电解质的反射率为0.02到0.05，对于金属来说，F0就是金属的本色，因此可以用0.04和本色为参数以金属度为比例做插值。
G项描述的是微表面对入射方向和出射方向的遮蔽比例，与法线分布是相关的。

>介绍IBL

IBL是模拟了间接光，将环境光提前烘焙到cubemap，在运行时根据法线方向查询间接光的radiance。
对于漫反射的渲染方程经过简化和近似后，积分项就只有入射方向Radiance和入射方向余弦了，这部分可以提前计算，得到的是一个相比原图很模糊的结果。
对于镜面反射，可以根据积分近似拆成两项，一部分是入射方向Radiance的积分，可以预计算，这部分额外考虑了粗糙度，越粗糙采样的向量会越分散，因此需要生成mipmap。在shader中可以根据粗糙度映射到mipmap的level。
虽然镜面反射受到观察方向的影响，预计算无法得知，但是我们可以假设镜面反射的方向总是等于采样的方向。这会导致当视线趋近于掠射角时，预计算的结果就不是很准确了。
另一部分是BRDF和入射方向余弦的积分，考虑Cook-Torrance的镜面反射项BRDF，经过变形后BRDF只受到粗糙度和半程向量夹角余弦的影响。这部分也可以预计算。

>光线追踪和路径追踪的区别

光线追踪是一种渲染方式，路径追踪是光线追踪的一种实现方法。
理想的光线追踪是从屏幕出发每个像素发射一根，击中物体表面后根据表面材质再次反射更多光线，多次弹射后射线数量会爆炸式增长。
而路径追踪则是根据表面材质只采样一个方向继续弹射，直到光线击中光源或者逃逸停止。这是因为利用了蒙特卡洛方法，反射光线的采样会考虑法线分布，这样反射的光线都是贡献比较大的。最终的结果要除去pdf。为了避免一直反射，可以增加俄罗斯轮盘赌，在结果也要除去轮盘赌的pdf

>如何理解重要性采样

延迟渲染第一个pass中

>介绍下延迟渲染管线



>实时阴影