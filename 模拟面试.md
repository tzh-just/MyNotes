### 渲染管线
**应用阶段**
- cpu将场景中的灯光、mesh、相机位置等信息传递给gpu
- cpu端可以根据场景管理，做视锥剔除，这是在mesh粒度上的剔除，减少向gpu传递的mesh数量。
  【重点 】GPU Driven：视锥剔除可以交给computer shader来做；遮挡剔除：Hiz、SOC
- cpu同时将材质、纹理、着色器等也传给gpu，然后向gpu发送drawcall命令， drawcall指向了一个要被渲染的顶点列表。
- cpu将命令放入命令缓冲区，gpu再取出来执行，cpu的drawcall太多往往是性能瓶颈。cpu可以通过批处理来减少drawcall的次数，以降低开销
- 【重点】动态合批是将同材质的mesh变换到世界空间后合并提交给gpu，适用于顶点数少的mesh，gpu instance对相同的mesh只提交一次，将每个mesh的变换矩阵、材质差异等送入缓冲区，在变换时把objectToWorld即M矩阵替换掉。
**几何阶段**
- 将顶点送入顶点着色器，在顶点着色器中进行各种变换，通过引入齐次坐标将线性变换和平移变换统一了起来。
- 这一步的最终目的是把顶点变换到-1到1的NDC空间中。首先根据模型变换到世界空间，根据相机变换到观察空间。
- 根据近平面远平面决定了投影变换的视体范围，如果是透视投影需要考虑fov，正交投影需要考虑尺寸大小。通过投影变换到齐次裁剪空间。
- 在齐次裁剪空间中可以做简单的、三角形粒度的视锥剔除，因为此时可以很容易判断三角形是否完全在视锥之外。
- 【重点】因为在透视除法后xy坐标是-1到1的，所以在除法前xy坐标的取值范围是-w到w，如果是opengl，则z也是-w到w，如果是dx则是0到w。
- 将这些三角形裁剪成多个，会更准确但也更耗费性能。对于在视锥面上的三角形可以等到在光栅化时通过视口和平面方程来裁剪。但这样简单处理实际上是有问题的。
- 【重点】因为此时如果有顶点在近平面后，在透视除法时会导致xy坐标翻转，得到不正确的NDC坐标。如果顶点恰好在视点的平面上，那么会导致除零的错误。
- NDC坐标经过屏幕映射后就得到了屏幕空间坐标。
**光栅化阶段**
- 顶点着色器输出的顶点数据会被组装成三角形图元，如点线面等。
- 然后对组装好的图元进行遍历，图元覆盖的每一个像素都会生成一个片元
- 【重点】图元覆盖像素的判断也有几种不同，在此基础上可以进行抗锯齿的计算，如SSAA，有四倍的颜色缓冲和深度缓冲，gpu会分配四个采样点，生成四倍的片元，进行四倍的计算，光栅化结束后将多重采样缓冲区下采样到帧缓冲。
- 【重点】MSAA与SSAA的区别在于，只会执行一次片元着色器，会根据片元与子采样点的覆盖与否，选择是否要把深度和颜色写入多重采样缓冲区，光栅化结束后将多重采样缓冲区下采样到帧缓。
- 此外，每个片元都需要根据三个顶点的数据，根据重心坐标进行插值计算，然后进行透视插值校正。片元与像素的区别就是，片元比像素多了这些插值信息。
- 【重点】之所以要做透视插值校正是因为，重心坐标是在屏幕空间计算的，计算出的结果不会考虑透视。齐次裁剪空间的w其实际上就是顶点的相机空间z值。该z值与屏幕空间的深度与其是成反比的。因此三个顶点在屏幕空间上计算得到的重心坐标需要分别除以自己的齐次裁剪空间w才是校正后的重心坐标。显然，硬件做透视除法之前得到了顶点的w，是可以自动完成这一操作的。
- 【重点】如果在片元着色器之前执行了深度测试，那么就是early-z。early-z在光照计算之前计算深度，好处是减少了不必要的overdraw，但是无法得到片元的透明度，也就不能进行半透明或全透明的渲染。
- 在片元着色器中计算光照后，如果开启了alpha测试，就会根据片元的alpha值决定是否丢弃片元，以实现全透明效果。
- 其次是进行深度测试，如果没有做early-z或开启了透明渲染，那么就会在这里进行深度测试，比较当前片元的深度与zbuffer中的深度。
- Alpha混合

双重缓冲
### PBR/IBL



### 延迟渲染管线


### 实时阴影