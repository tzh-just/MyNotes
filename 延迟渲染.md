**第一个Pass**
采样PBR材质的各种纹理贴图，然后在片元着色器中将计算光照相关的数据编码到Render Texture，如基本颜色、金属度、世界空间法线、自发光项、粗糙度和AO。
```c
o.GT0 = half4(BaseColor, Metallic);
o.GT1 = half4(PackNormal2Color(N),1);
o.GT2 = half4(Emission,Roughness);
o.GT3 = half4(AO,1);
```
需要注意的是，法线的范围是[-1,1]，保存时需要映射到[0,1]，使用时需要映射回[-1,1]。
```cpp
half3 PackNormal2Color(half3 normal){
    return normal * 0.5 + 0.5;
}
half3 UnpackColor2Normal(half3 color){
    return color * 2 - 1;
}
```
**第二个Pass**
在片元着色器中将Render Texture中的数据取出。需要注意，法线应先解码。
```c
half3 BaseColor = tex2D(_GT0,uv).rgb;
half  Metallic  = tex2D(_GT0,uv).a;
half3 Normal    = UnpackColor2Normal(tex2D(_GT1,uv).rgb);
half3 Emission  = tex2D(_GT2,uv).rgb;
half  Roughness = tex2D(_GT2,uv).a;
half3 AO        = tex2D(_GT3,uv).rgb;
```
在延迟渲染管线中，第二个Pass不能像前向渲染那样在顶点着色器中输出顶点的世界空间坐标。但延迟渲染可以通过顶点在屏幕空间的uv坐标，加上深度缓存来反推出NDC坐标，再进一步地通过NDC坐标反推出世界空间坐标。
```c
half d = UNITY_SAMPLE_DEPTH(tex2D(_gdepth, uv));
half4 ndcPos = half4(uv*2-1,d,1);
half4 worldPos = mul(_vpMatrixInv, ndcPos);
worldPos /= worldPos.w;
```
之所以可以直接从uv坐标还原NDC坐标，这是因为对于第二个Pass，Blit函数的作用是绘制一个覆盖了整个屏幕的Quad，然后调用shader将渲染结果写入Render Texture中，作为相机的渲染目标。因此0到1的uv坐标就是屏幕每个像素的的NDC.xy。
```cpp
void LightPass(ScriptableRenderContext context, Camera camera){
	CommandBuffer cmd = new CommandBuffer();
	cmd.name = "LightPass";
	Material mat = new Material(Shader.Find("JustRP/LightPass"));
	cmd.Blit(gbufferID[0], BuiltinRenderTextureType.CameraTarget, mat);
	context.ExecuteCommandBuffer(cmd);
}
```
**世界空间坐标**
我们需要顶点的世界空间坐标来计算世界空间下的观察方向、光照方向和光照距离等等数据。直觉上我们应该先把NCD坐标乘以w得到裁剪空间坐标，再经过逆VP变换得到世界空间坐标。但由于透视除法是硬件自动执行的，我们想要获取这一数值则需要顶点着色器向片元着色器输出。已知投影变换之前$\text{w}=1$，即NDC坐标经过逆VP变换后得到的$\text{w}$与$\text{w}_{\text{clip}}$相乘等于1。经过观察发现除了$\text{w}_{clip}$其他项都是已知的，将$\text{w}_{clip}$的表达式代回原式得到世界空间坐标。
$$
P_{\text {world }}  =M_{\text {VP }}^{-1} * P_{\text {ndc }} * \text{w}_{\text {clip }}
$$
$$
1  =\left(M_{\text {VP }}^{-1} * P_{\text {ndc }}\right).\text{w} * \text{w}_{\text {clip }}
$$
$$
\text{w}_{\text{clip}} = \frac{1}{M_{\text{VP}}^{-1}*P_{\text{ndc}}}
$$
$$
P_{\text{world}} = \frac{M_{\text{VP}}^{-1} *   P_{\text{ndc}}}{(M_{\text{VP}}^{-1} \cdot  P_{\text{ndc}}).\text{w}}
$$
**光照的计算**
遍历每个光源计算光照，假设有m个网格，n个光源，则我们需要对N个网格执行第一个Pass，对m个光源执行第二个Pass。因此延迟渲染的复杂度为$O(m+n)$。
![[Pasted image 20230708010226.png]]